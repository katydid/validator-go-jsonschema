// Code generated by funcs-gen. DO NOT EDIT.
package funcs

import (
	"bytes"
	"strings"
)

type doubleGE struct {
	V1          Double
	V2          Double
	hash        uint64
	hasVariable bool
}

func (this *doubleGE) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 >= v2, nil
}

func (this *doubleGE) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*doubleGE); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *doubleGE) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return ">= " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return ">= " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *doubleGE) String() string {
	return "ge" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *doubleGE) HasVariable() bool {
	return this.hasVariable
}

func (this *doubleGE) Hash() uint64 {
	return this.hash
}

func init() {
	Register("ge", DoubleGE)
}

// DoubleGE returns a new greater than or equal function.
func DoubleGE(a, b Double) Bool {
	return TrimBool(&doubleGE{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3294, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type intGE struct {
	V1          Int
	V2          Int
	hash        uint64
	hasVariable bool
}

func (this *intGE) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 >= v2, nil
}

func (this *intGE) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*intGE); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *intGE) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return ">= " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return ">= " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *intGE) String() string {
	return "ge" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *intGE) HasVariable() bool {
	return this.hasVariable
}

func (this *intGE) Hash() uint64 {
	return this.hash
}

func init() {
	Register("ge", IntGE)
}

// IntGE returns a new greater than or equal function.
func IntGE(a, b Int) Bool {
	return TrimBool(&intGE{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3294, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type uintGE struct {
	V1          Uint
	V2          Uint
	hash        uint64
	hasVariable bool
}

func (this *uintGE) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 >= v2, nil
}

func (this *uintGE) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*uintGE); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *uintGE) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return ">= " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return ">= " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *uintGE) String() string {
	return "ge" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *uintGE) HasVariable() bool {
	return this.hasVariable
}

func (this *uintGE) Hash() uint64 {
	return this.hash
}

func init() {
	Register("ge", UintGE)
}

// UintGE returns a new greater than or equal function.
func UintGE(a, b Uint) Bool {
	return TrimBool(&uintGE{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3294, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type bytesGE struct {
	V1          Bytes
	V2          Bytes
	hash        uint64
	hasVariable bool
}

func (this *bytesGE) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return bytes.Compare(v1, v2) >= 0, nil
}

func (this *bytesGE) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*bytesGE); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *bytesGE) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return ">= " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return ">= " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *bytesGE) String() string {
	return "ge" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *bytesGE) HasVariable() bool {
	return this.hasVariable
}

func (this *bytesGE) Hash() uint64 {
	return this.hash
}

func init() {
	Register("ge", BytesGE)
}

// BytesGE returns a new greater than or equal function.
func BytesGE(a, b Bytes) Bool {
	return TrimBool(&bytesGE{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3294, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type doubleGt struct {
	V1          Double
	V2          Double
	hash        uint64
	hasVariable bool
}

func (this *doubleGt) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 > v2, nil
}

func (this *doubleGt) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*doubleGt); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *doubleGt) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "> " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "> " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *doubleGt) String() string {
	return "gt" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *doubleGt) HasVariable() bool {
	return this.hasVariable
}

func (this *doubleGt) Hash() uint64 {
	return this.hash
}

func init() {
	Register("gt", DoubleGt)
}

// DoubleGt returns a new greater than function.
func DoubleGt(a, b Double) Bool {
	return TrimBool(&doubleGt{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3309, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type intGt struct {
	V1          Int
	V2          Int
	hash        uint64
	hasVariable bool
}

func (this *intGt) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 > v2, nil
}

func (this *intGt) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*intGt); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *intGt) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "> " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "> " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *intGt) String() string {
	return "gt" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *intGt) HasVariable() bool {
	return this.hasVariable
}

func (this *intGt) Hash() uint64 {
	return this.hash
}

func init() {
	Register("gt", IntGt)
}

// IntGt returns a new greater than function.
func IntGt(a, b Int) Bool {
	return TrimBool(&intGt{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3309, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type uintGt struct {
	V1          Uint
	V2          Uint
	hash        uint64
	hasVariable bool
}

func (this *uintGt) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 > v2, nil
}

func (this *uintGt) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*uintGt); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *uintGt) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "> " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "> " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *uintGt) String() string {
	return "gt" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *uintGt) HasVariable() bool {
	return this.hasVariable
}

func (this *uintGt) Hash() uint64 {
	return this.hash
}

func init() {
	Register("gt", UintGt)
}

// UintGt returns a new greater than function.
func UintGt(a, b Uint) Bool {
	return TrimBool(&uintGt{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3309, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type bytesGt struct {
	V1          Bytes
	V2          Bytes
	hash        uint64
	hasVariable bool
}

func (this *bytesGt) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return bytes.Compare(v1, v2) > 0, nil
}

func (this *bytesGt) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*bytesGt); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *bytesGt) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "> " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "> " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *bytesGt) String() string {
	return "gt" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *bytesGt) HasVariable() bool {
	return this.hasVariable
}

func (this *bytesGt) Hash() uint64 {
	return this.hash
}

func init() {
	Register("gt", BytesGt)
}

// BytesGt returns a new greater than function.
func BytesGt(a, b Bytes) Bool {
	return TrimBool(&bytesGt{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3309, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type doubleLE struct {
	V1          Double
	V2          Double
	hash        uint64
	hasVariable bool
}

func (this *doubleLE) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 <= v2, nil
}

func (this *doubleLE) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*doubleLE); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *doubleLE) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "<= " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "<= " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *doubleLE) String() string {
	return "le" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *doubleLE) HasVariable() bool {
	return this.hasVariable
}

func (this *doubleLE) Hash() uint64 {
	return this.hash
}

func init() {
	Register("le", DoubleLE)
}

// DoubleLE returns a new less than or equal function.
func DoubleLE(a, b Double) Bool {
	return TrimBool(&doubleLE{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3449, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type intLE struct {
	V1          Int
	V2          Int
	hash        uint64
	hasVariable bool
}

func (this *intLE) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 <= v2, nil
}

func (this *intLE) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*intLE); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *intLE) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "<= " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "<= " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *intLE) String() string {
	return "le" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *intLE) HasVariable() bool {
	return this.hasVariable
}

func (this *intLE) Hash() uint64 {
	return this.hash
}

func init() {
	Register("le", IntLE)
}

// IntLE returns a new less than or equal function.
func IntLE(a, b Int) Bool {
	return TrimBool(&intLE{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3449, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type uintLE struct {
	V1          Uint
	V2          Uint
	hash        uint64
	hasVariable bool
}

func (this *uintLE) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 <= v2, nil
}

func (this *uintLE) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*uintLE); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *uintLE) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "<= " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "<= " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *uintLE) String() string {
	return "le" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *uintLE) HasVariable() bool {
	return this.hasVariable
}

func (this *uintLE) Hash() uint64 {
	return this.hash
}

func init() {
	Register("le", UintLE)
}

// UintLE returns a new less than or equal function.
func UintLE(a, b Uint) Bool {
	return TrimBool(&uintLE{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3449, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type bytesLE struct {
	V1          Bytes
	V2          Bytes
	hash        uint64
	hasVariable bool
}

func (this *bytesLE) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return bytes.Compare(v1, v2) <= 0, nil
}

func (this *bytesLE) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*bytesLE); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *bytesLE) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "<= " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "<= " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *bytesLE) String() string {
	return "le" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *bytesLE) HasVariable() bool {
	return this.hasVariable
}

func (this *bytesLE) Hash() uint64 {
	return this.hash
}

func init() {
	Register("le", BytesLE)
}

// BytesLE returns a new less than or equal function.
func BytesLE(a, b Bytes) Bool {
	return TrimBool(&bytesLE{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3449, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type doubleLt struct {
	V1          Double
	V2          Double
	hash        uint64
	hasVariable bool
}

func (this *doubleLt) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 < v2, nil
}

func (this *doubleLt) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*doubleLt); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *doubleLt) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "< " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "< " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *doubleLt) String() string {
	return "lt" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *doubleLt) HasVariable() bool {
	return this.hasVariable
}

func (this *doubleLt) Hash() uint64 {
	return this.hash
}

func init() {
	Register("lt", DoubleLt)
}

// DoubleLt returns a new less than function.
func DoubleLt(a, b Double) Bool {
	return TrimBool(&doubleLt{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3464, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type intLt struct {
	V1          Int
	V2          Int
	hash        uint64
	hasVariable bool
}

func (this *intLt) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 < v2, nil
}

func (this *intLt) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*intLt); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *intLt) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "< " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "< " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *intLt) String() string {
	return "lt" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *intLt) HasVariable() bool {
	return this.hasVariable
}

func (this *intLt) Hash() uint64 {
	return this.hash
}

func init() {
	Register("lt", IntLt)
}

// IntLt returns a new less than function.
func IntLt(a, b Int) Bool {
	return TrimBool(&intLt{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3464, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type uintLt struct {
	V1          Uint
	V2          Uint
	hash        uint64
	hasVariable bool
}

func (this *uintLt) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 < v2, nil
}

func (this *uintLt) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*uintLt); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *uintLt) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "< " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "< " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *uintLt) String() string {
	return "lt" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *uintLt) HasVariable() bool {
	return this.hasVariable
}

func (this *uintLt) Hash() uint64 {
	return this.hash
}

func init() {
	Register("lt", UintLt)
}

// UintLt returns a new less than function.
func UintLt(a, b Uint) Bool {
	return TrimBool(&uintLt{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3464, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type bytesLt struct {
	V1          Bytes
	V2          Bytes
	hash        uint64
	hasVariable bool
}

func (this *bytesLt) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return bytes.Compare(v1, v2) < 0, nil
}

func (this *bytesLt) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*bytesLt); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *bytesLt) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "< " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "< " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *bytesLt) String() string {
	return "lt" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *bytesLt) HasVariable() bool {
	return this.hasVariable
}

func (this *bytesLt) Hash() uint64 {
	return this.hash
}

func init() {
	Register("lt", BytesLt)
}

// BytesLt returns a new less than function.
func BytesLt(a, b Bytes) Bool {
	return TrimBool(&bytesLt{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3464, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type doubleEq struct {
	V1          Double
	V2          Double
	hash        uint64
	hasVariable bool
}

func (this *doubleEq) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 == v2, nil
}

func (this *doubleEq) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*doubleEq); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *doubleEq) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "== " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "== " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *doubleEq) String() string {
	return "eq" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *doubleEq) HasVariable() bool {
	return this.hasVariable
}

func (this *doubleEq) Hash() uint64 {
	return this.hash
}

func init() {
	Register("eq", DoubleEq)
}

// DoubleEq returns a new equal function.
func DoubleEq(a, b Double) Bool {
	return TrimBool(&doubleEq{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3244, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type intEq struct {
	V1          Int
	V2          Int
	hash        uint64
	hasVariable bool
}

func (this *intEq) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 == v2, nil
}

func (this *intEq) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*intEq); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *intEq) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "== " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "== " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *intEq) String() string {
	return "eq" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *intEq) HasVariable() bool {
	return this.hasVariable
}

func (this *intEq) Hash() uint64 {
	return this.hash
}

func init() {
	Register("eq", IntEq)
}

// IntEq returns a new equal function.
func IntEq(a, b Int) Bool {
	return TrimBool(&intEq{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3244, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type uintEq struct {
	V1          Uint
	V2          Uint
	hash        uint64
	hasVariable bool
}

func (this *uintEq) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 == v2, nil
}

func (this *uintEq) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*uintEq); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *uintEq) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "== " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "== " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *uintEq) String() string {
	return "eq" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *uintEq) HasVariable() bool {
	return this.hasVariable
}

func (this *uintEq) Hash() uint64 {
	return this.hash
}

func init() {
	Register("eq", UintEq)
}

// UintEq returns a new equal function.
func UintEq(a, b Uint) Bool {
	return TrimBool(&uintEq{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3244, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type boolEq struct {
	V1          Bool
	V2          Bool
	hash        uint64
	hasVariable bool
}

func (this *boolEq) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 == v2, nil
}

func (this *boolEq) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*boolEq); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *boolEq) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "== " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "== " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *boolEq) String() string {
	return "eq" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *boolEq) HasVariable() bool {
	return this.hasVariable
}

func (this *boolEq) Hash() uint64 {
	return this.hash
}

func init() {
	Register("eq", BoolEq)
}

// BoolEq returns a new equal function.
func BoolEq(a, b Bool) Bool {
	return TrimBool(&boolEq{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3244, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type stringEq struct {
	V1          String
	V2          String
	hash        uint64
	hasVariable bool
}

func (this *stringEq) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 == v2, nil
}

func (this *stringEq) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*stringEq); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *stringEq) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "== " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "== " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *stringEq) String() string {
	return "eq" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *stringEq) HasVariable() bool {
	return this.hasVariable
}

func (this *stringEq) Hash() uint64 {
	return this.hash
}

func init() {
	Register("eq", StringEq)
}

// StringEq returns a new equal function.
func StringEq(a, b String) Bool {
	return TrimBool(&stringEq{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3244, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type bytesEq struct {
	V1          Bytes
	V2          Bytes
	hash        uint64
	hasVariable bool
}

func (this *bytesEq) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return bytes.Equal(v1, v2), nil
}

func (this *bytesEq) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*bytesEq); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *bytesEq) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "== " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "== " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *bytesEq) String() string {
	return "eq" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *bytesEq) HasVariable() bool {
	return this.hasVariable
}

func (this *bytesEq) Hash() uint64 {
	return this.hash
}

func init() {
	Register("eq", BytesEq)
}

// BytesEq returns a new equal function.
func BytesEq(a, b Bytes) Bool {
	return TrimBool(&bytesEq{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3244, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type doubleNe struct {
	V1          Double
	V2          Double
	hash        uint64
	hasVariable bool
}

func (this *doubleNe) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 != v2, nil
}

func (this *doubleNe) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*doubleNe); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *doubleNe) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "!= " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "!= " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *doubleNe) String() string {
	return "ne" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *doubleNe) HasVariable() bool {
	return this.hasVariable
}

func (this *doubleNe) Hash() uint64 {
	return this.hash
}

func init() {
	Register("ne", DoubleNe)
}

// DoubleNe returns a new not equal function.
func DoubleNe(a, b Double) Bool {
	return TrimBool(&doubleNe{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3511, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type intNe struct {
	V1          Int
	V2          Int
	hash        uint64
	hasVariable bool
}

func (this *intNe) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 != v2, nil
}

func (this *intNe) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*intNe); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *intNe) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "!= " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "!= " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *intNe) String() string {
	return "ne" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *intNe) HasVariable() bool {
	return this.hasVariable
}

func (this *intNe) Hash() uint64 {
	return this.hash
}

func init() {
	Register("ne", IntNe)
}

// IntNe returns a new not equal function.
func IntNe(a, b Int) Bool {
	return TrimBool(&intNe{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3511, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type uintNe struct {
	V1          Uint
	V2          Uint
	hash        uint64
	hasVariable bool
}

func (this *uintNe) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 != v2, nil
}

func (this *uintNe) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*uintNe); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *uintNe) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "!= " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "!= " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *uintNe) String() string {
	return "ne" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *uintNe) HasVariable() bool {
	return this.hasVariable
}

func (this *uintNe) Hash() uint64 {
	return this.hash
}

func init() {
	Register("ne", UintNe)
}

// UintNe returns a new not equal function.
func UintNe(a, b Uint) Bool {
	return TrimBool(&uintNe{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3511, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type boolNe struct {
	V1          Bool
	V2          Bool
	hash        uint64
	hasVariable bool
}

func (this *boolNe) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 != v2, nil
}

func (this *boolNe) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*boolNe); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *boolNe) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "!= " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "!= " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *boolNe) String() string {
	return "ne" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *boolNe) HasVariable() bool {
	return this.hasVariable
}

func (this *boolNe) Hash() uint64 {
	return this.hash
}

func init() {
	Register("ne", BoolNe)
}

// BoolNe returns a new not equal function.
func BoolNe(a, b Bool) Bool {
	return TrimBool(&boolNe{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3511, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type stringNe struct {
	V1          String
	V2          String
	hash        uint64
	hasVariable bool
}

func (this *stringNe) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 != v2, nil
}

func (this *stringNe) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*stringNe); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *stringNe) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "!= " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "!= " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *stringNe) String() string {
	return "ne" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *stringNe) HasVariable() bool {
	return this.hasVariable
}

func (this *stringNe) Hash() uint64 {
	return this.hash
}

func init() {
	Register("ne", StringNe)
}

// StringNe returns a new not equal function.
func StringNe(a, b String) Bool {
	return TrimBool(&stringNe{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3511, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}

type bytesNe struct {
	V1          Bytes
	V2          Bytes
	hash        uint64
	hasVariable bool
}

func (this *bytesNe) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return !bytes.Equal(v1, v2), nil
}

func (this *bytesNe) Compare(that Comparable) int {
	if this.Hash() != that.Hash() {
		if this.Hash() < that.Hash() {
			return -1
		}
		return 1
	}
	if other, ok := that.(*bytesNe); ok {
		if c := this.V1.Compare(other.V1); c != 0 {
			return c
		}
		if c := this.V2.Compare(other.V2); c != 0 {
			return c
		}
		return 0
	}
	return strings.Compare(this.String(), that.String())
}

func (this *bytesNe) Shorthand() (string, bool) {
	if _, ok1 := this.V1.(aVariable); ok1 {
		if _, ok2 := this.V2.(aConst); ok2 {
			return "!= " + this.V2.String(), true
		}
	}
	if _, ok2 := this.V2.(aVariable); ok2 {
		if _, ok1 := this.V1.(aConst); ok1 {
			return "!= " + this.V1.String(), true
		}
	}
	return "", false
}

func (this *bytesNe) String() string {
	return "ne" + "(" + sjoin(this.V1, this.V2) + ")"
}

func (this *bytesNe) HasVariable() bool {
	return this.hasVariable
}

func (this *bytesNe) Hash() uint64 {
	return this.hash
}

func init() {
	Register("ne", BytesNe)
}

// BytesNe returns a new not equal function.
func BytesNe(a, b Bytes) Bool {
	return TrimBool(&bytesNe{
		V1:          a,
		V2:          b,
		hash:        hashWithId(3511, a, b),
		hasVariable: a.HasVariable() || b.HasVariable(),
	})
}
