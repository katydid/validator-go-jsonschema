// Code generated by funcs-gen. DO NOT EDIT.
package funcs

import (
	"fmt"
	"reflect"
	"strings"
)

type ConstDouble interface {
	Double
}

var typConstDouble reflect.Type = reflect.TypeOf((*ConstDouble)(nil)).Elem()

type constDouble struct {
	v    float64
	hash uint64
}

// DoubleConst returns a new constant function of type Double
func DoubleConst(v float64) ConstDouble {
	h := uint64(17)
	h = 31*h + 2052876273
	h = 31*h + deriveHashDouble(v)
	return &constDouble{v, h}
}

func (this *constDouble) IsConst() {}

func (this *constDouble) Eval() (float64, error) {
	return this.v, nil
}

func (this *constDouble) HasVariable() bool { return false }

func (this *constDouble) Hash() uint64 {
	return this.hash
}

func (this *constDouble) String() string {
	return fmt.Sprintf("double(%f)", this.v)
}

// TrimDouble turns functions into constants, if they can be evaluated at compile time.
func TrimDouble(f Double) Double {
	if _, ok := f.(Const); ok {
		return f
	}
	if f.HasVariable() {
		return f
	}
	v, err := f.Eval()
	if err != nil {
		return f
	}
	return DoubleConst(v)
}

type ConstInt interface {
	Int
}

var typConstInt reflect.Type = reflect.TypeOf((*ConstInt)(nil)).Elem()

type constInt struct {
	v    int64
	hash uint64
}

// IntConst returns a new constant function of type Int
func IntConst(v int64) ConstInt {
	h := uint64(17)
	h = 31*h + 73679
	h = 31*h + deriveHashInt(v)
	return &constInt{v, h}
}

func (this *constInt) IsConst() {}

func (this *constInt) Eval() (int64, error) {
	return this.v, nil
}

func (this *constInt) HasVariable() bool { return false }

func (this *constInt) Hash() uint64 {
	return this.hash
}

func (this *constInt) String() string {
	return fmt.Sprintf("int(%d)", this.v)
}

// TrimInt turns functions into constants, if they can be evaluated at compile time.
func TrimInt(f Int) Int {
	if _, ok := f.(Const); ok {
		return f
	}
	if f.HasVariable() {
		return f
	}
	v, err := f.Eval()
	if err != nil {
		return f
	}
	return IntConst(v)
}

type ConstUint interface {
	Uint
}

var typConstUint reflect.Type = reflect.TypeOf((*ConstUint)(nil)).Elem()

type constUint struct {
	v    uint64
	hash uint64
}

// UintConst returns a new constant function of type Uint
func UintConst(v uint64) ConstUint {
	h := uint64(17)
	h = 31*h + 2636666
	h = 31*h + deriveHashUint(v)
	return &constUint{v, h}
}

func (this *constUint) IsConst() {}

func (this *constUint) Eval() (uint64, error) {
	return this.v, nil
}

func (this *constUint) HasVariable() bool { return false }

func (this *constUint) Hash() uint64 {
	return this.hash
}

func (this *constUint) String() string {
	return fmt.Sprintf("uint(%d)", this.v)
}

// TrimUint turns functions into constants, if they can be evaluated at compile time.
func TrimUint(f Uint) Uint {
	if _, ok := f.(Const); ok {
		return f
	}
	if f.HasVariable() {
		return f
	}
	v, err := f.Eval()
	if err != nil {
		return f
	}
	return UintConst(v)
}

type ConstBool interface {
	Bool
}

var typConstBool reflect.Type = reflect.TypeOf((*ConstBool)(nil)).Elem()

type constBool struct {
	v    bool
	hash uint64
}

// BoolConst returns a new constant function of type Bool
func BoolConst(v bool) ConstBool {
	h := uint64(17)
	h = 31*h + 2076426
	h = 31*h + deriveHashBool(v)
	return &constBool{v, h}
}

func (this *constBool) IsConst() {}

func (this *constBool) Eval() (bool, error) {
	return this.v, nil
}

func (this *constBool) HasVariable() bool { return false }

func (this *constBool) Hash() uint64 {
	return this.hash
}

func (this *constBool) String() string {
	return fmt.Sprintf("%v", this.v)
}

// TrimBool turns functions into constants, if they can be evaluated at compile time.
func TrimBool(f Bool) Bool {
	if _, ok := f.(Const); ok {
		return f
	}
	if f.HasVariable() {
		return f
	}
	v, err := f.Eval()
	if err != nil {
		return f
	}
	return BoolConst(v)
}

type ConstString interface {
	String
}

var typConstString reflect.Type = reflect.TypeOf((*ConstString)(nil)).Elem()

type constString struct {
	v    string
	hash uint64
}

// StringConst returns a new constant function of type String
func StringConst(v string) ConstString {
	h := uint64(17)
	h = 31*h + 2486848561
	h = 31*h + deriveHashString(v)
	return &constString{v, h}
}

func (this *constString) IsConst() {}

func (this *constString) Eval() (string, error) {
	return this.v, nil
}

func (this *constString) HasVariable() bool { return false }

func (this *constString) Hash() uint64 {
	return this.hash
}

func (this *constString) String() string {
	return fmt.Sprintf("`%s`", this.v)
}

// TrimString turns functions into constants, if they can be evaluated at compile time.
func TrimString(f String) String {
	if _, ok := f.(Const); ok {
		return f
	}
	if f.HasVariable() {
		return f
	}
	v, err := f.Eval()
	if err != nil {
		return f
	}
	return StringConst(v)
}

type ConstBytes interface {
	Bytes
}

var typConstBytes reflect.Type = reflect.TypeOf((*ConstBytes)(nil)).Elem()

type constBytes struct {
	v    []byte
	hash uint64
}

// BytesConst returns a new constant function of type Bytes
func BytesConst(v []byte) ConstBytes {
	h := uint64(17)
	h = 31*h + 64671819
	h = 31*h + deriveHashBytes(v)
	return &constBytes{v, h}
}

func (this *constBytes) IsConst() {}

func (this *constBytes) Eval() ([]byte, error) {
	return this.v, nil
}

func (this *constBytes) HasVariable() bool { return false }

func (this *constBytes) Hash() uint64 {
	return this.hash
}

func (this *constBytes) String() string {
	return fmt.Sprintf("%#v", this.v)
}

// TrimBytes turns functions into constants, if they can be evaluated at compile time.
func TrimBytes(f Bytes) Bytes {
	if _, ok := f.(Const); ok {
		return f
	}
	if f.HasVariable() {
		return f
	}
	v, err := f.Eval()
	if err != nil {
		return f
	}
	return BytesConst(v)
}

type ConstDoubles interface {
	Doubles
}

var typConstDoubles reflect.Type = reflect.TypeOf((*ConstDoubles)(nil)).Elem()

type constDoubles struct {
	v    []float64
	hash uint64
}

// DoublesConst returns a new constant function of type Doubles
func DoublesConst(v []float64) ConstDoubles {
	h := uint64(17)
	h = 31*h + 63639164578
	h = 31*h + deriveHashDoubles(v)
	return &constDoubles{v, h}
}

func (this *constDoubles) IsConst() {}

func (this *constDoubles) Eval() ([]float64, error) {
	return this.v, nil
}

func (this *constDoubles) HasVariable() bool { return false }

func (this *constDoubles) Hash() uint64 {
	return this.hash
}

func (this *constDoubles) String() string {
	ss := make([]string, len(this.v))
	for i := range this.v {
		ss[i] = fmt.Sprintf("double(%f)", this.v[i])
	}
	return "[]double{" + strings.Join(ss, ",") + "}"
}

// TrimDoubles turns functions into constants, if they can be evaluated at compile time.
func TrimDoubles(f Doubles) Doubles {
	if _, ok := f.(Const); ok {
		return f
	}
	if f.HasVariable() {
		return f
	}
	v, err := f.Eval()
	if err != nil {
		return f
	}
	return DoublesConst(v)
}

type ConstInts interface {
	Ints
}

var typConstInts reflect.Type = reflect.TypeOf((*ConstInts)(nil)).Elem()

type constInts struct {
	v    []int64
	hash uint64
}

// IntsConst returns a new constant function of type Ints
func IntsConst(v []int64) ConstInts {
	h := uint64(17)
	h = 31*h + 2284164
	h = 31*h + deriveHashInts(v)
	return &constInts{v, h}
}

func (this *constInts) IsConst() {}

func (this *constInts) Eval() ([]int64, error) {
	return this.v, nil
}

func (this *constInts) HasVariable() bool { return false }

func (this *constInts) Hash() uint64 {
	return this.hash
}

func (this *constInts) String() string {
	ss := make([]string, len(this.v))
	for i := range this.v {
		ss[i] = fmt.Sprintf("int(%d)", this.v[i])
	}
	return "[]int{" + strings.Join(ss, ",") + "}"
}

// TrimInts turns functions into constants, if they can be evaluated at compile time.
func TrimInts(f Ints) Ints {
	if _, ok := f.(Const); ok {
		return f
	}
	if f.HasVariable() {
		return f
	}
	v, err := f.Eval()
	if err != nil {
		return f
	}
	return IntsConst(v)
}

type ConstUints interface {
	Uints
}

var typConstUints reflect.Type = reflect.TypeOf((*ConstUints)(nil)).Elem()

type constUints struct {
	v    []uint64
	hash uint64
}

// UintsConst returns a new constant function of type Uints
func UintsConst(v []uint64) ConstUints {
	h := uint64(17)
	h = 31*h + 81736761
	h = 31*h + deriveHashUints(v)
	return &constUints{v, h}
}

func (this *constUints) IsConst() {}

func (this *constUints) Eval() ([]uint64, error) {
	return this.v, nil
}

func (this *constUints) HasVariable() bool { return false }

func (this *constUints) Hash() uint64 {
	return this.hash
}

func (this *constUints) String() string {
	ss := make([]string, len(this.v))
	for i := range this.v {
		ss[i] = fmt.Sprintf("uint(%d)", this.v[i])
	}
	return "[]uint{" + strings.Join(ss, ",") + "}"
}

// TrimUints turns functions into constants, if they can be evaluated at compile time.
func TrimUints(f Uints) Uints {
	if _, ok := f.(Const); ok {
		return f
	}
	if f.HasVariable() {
		return f
	}
	v, err := f.Eval()
	if err != nil {
		return f
	}
	return UintsConst(v)
}

type ConstBools interface {
	Bools
}

var typConstBools reflect.Type = reflect.TypeOf((*ConstBools)(nil)).Elem()

type constBools struct {
	v    []bool
	hash uint64
}

// BoolsConst returns a new constant function of type Bools
func BoolsConst(v []bool) ConstBools {
	h := uint64(17)
	h = 31*h + 64369321
	h = 31*h + deriveHashBools(v)
	return &constBools{v, h}
}

func (this *constBools) IsConst() {}

func (this *constBools) Eval() ([]bool, error) {
	return this.v, nil
}

func (this *constBools) HasVariable() bool { return false }

func (this *constBools) Hash() uint64 {
	return this.hash
}

func (this *constBools) String() string {
	ss := make([]string, len(this.v))
	for i := range this.v {
		ss[i] = fmt.Sprintf("%v", this.v[i])
	}
	return "[]bool{" + strings.Join(ss, ",") + "}"
}

// TrimBools turns functions into constants, if they can be evaluated at compile time.
func TrimBools(f Bools) Bools {
	if _, ok := f.(Const); ok {
		return f
	}
	if f.HasVariable() {
		return f
	}
	v, err := f.Eval()
	if err != nil {
		return f
	}
	return BoolsConst(v)
}

type ConstStrings interface {
	Strings
}

var typConstStrings reflect.Type = reflect.TypeOf((*ConstStrings)(nil)).Elem()

type constStrings struct {
	v    []string
	hash uint64
}

// StringsConst returns a new constant function of type Strings
func StringsConst(v []string) ConstStrings {
	h := uint64(17)
	h = 31*h + 77092305506
	h = 31*h + deriveHashStrings(v)
	return &constStrings{v, h}
}

func (this *constStrings) IsConst() {}

func (this *constStrings) Eval() ([]string, error) {
	return this.v, nil
}

func (this *constStrings) HasVariable() bool { return false }

func (this *constStrings) Hash() uint64 {
	return this.hash
}

func (this *constStrings) String() string {
	ss := make([]string, len(this.v))
	for i := range this.v {
		ss[i] = fmt.Sprintf("`%s`", this.v[i])
	}
	return "[]string{" + strings.Join(ss, ",") + "}"
}

// TrimStrings turns functions into constants, if they can be evaluated at compile time.
func TrimStrings(f Strings) Strings {
	if _, ok := f.(Const); ok {
		return f
	}
	if f.HasVariable() {
		return f
	}
	v, err := f.Eval()
	if err != nil {
		return f
	}
	return StringsConst(v)
}

type ConstListOfBytes interface {
	ListOfBytes
}

var typConstListOfBytes reflect.Type = reflect.TypeOf((*ConstListOfBytes)(nil)).Elem()

type constListOfBytes struct {
	v    [][]byte
	hash uint64
}

// ListOfBytesConst returns a new constant function of type ListOfBytes
func ListOfBytesConst(v [][]byte) ConstListOfBytes {
	h := uint64(17)
	h = 31*h + 65169257167589942
	h = 31*h + deriveHashListOfBytes(v)
	return &constListOfBytes{v, h}
}

func (this *constListOfBytes) IsConst() {}

func (this *constListOfBytes) Eval() ([][]byte, error) {
	return this.v, nil
}

func (this *constListOfBytes) HasVariable() bool { return false }

func (this *constListOfBytes) Hash() uint64 {
	return this.hash
}

func (this *constListOfBytes) String() string {
	ss := make([]string, len(this.v))
	for i := range this.v {
		ss[i] = fmt.Sprintf("%#v", this.v[i])
	}
	return "[][]byte{" + strings.Join(ss, ",") + "}"
}

// TrimListOfBytes turns functions into constants, if they can be evaluated at compile time.
func TrimListOfBytes(f ListOfBytes) ListOfBytes {
	if _, ok := f.(Const); ok {
		return f
	}
	if f.HasVariable() {
		return f
	}
	v, err := f.Eval()
	if err != nil {
		return f
	}
	return ListOfBytesConst(v)
}
