// Code generated by funcs-gen. DO NOT EDIT.
package funcs

// NewDouble dynamically creates and asserts the returning function is of type Double.
// This function is used by the compose library to compile functions together.
func (f *Maker) NewDouble(values ...interface{}) (Double, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Double), nil
}

// NewInt dynamically creates and asserts the returning function is of type Int.
// This function is used by the compose library to compile functions together.
func (f *Maker) NewInt(values ...interface{}) (Int, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Int), nil
}

// NewUint dynamically creates and asserts the returning function is of type Uint.
// This function is used by the compose library to compile functions together.
func (f *Maker) NewUint(values ...interface{}) (Uint, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Uint), nil
}

// NewBool dynamically creates and asserts the returning function is of type Bool.
// This function is used by the compose library to compile functions together.
func (f *Maker) NewBool(values ...interface{}) (Bool, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Bool), nil
}

// NewString dynamically creates and asserts the returning function is of type String.
// This function is used by the compose library to compile functions together.
func (f *Maker) NewString(values ...interface{}) (String, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(String), nil
}

// NewBytes dynamically creates and asserts the returning function is of type Bytes.
// This function is used by the compose library to compile functions together.
func (f *Maker) NewBytes(values ...interface{}) (Bytes, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Bytes), nil
}

// NewDoubles dynamically creates and asserts the returning function is of type Doubles.
// This function is used by the compose library to compile functions together.
func (f *Maker) NewDoubles(values ...interface{}) (Doubles, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Doubles), nil
}

// NewInts dynamically creates and asserts the returning function is of type Ints.
// This function is used by the compose library to compile functions together.
func (f *Maker) NewInts(values ...interface{}) (Ints, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Ints), nil
}

// NewUints dynamically creates and asserts the returning function is of type Uints.
// This function is used by the compose library to compile functions together.
func (f *Maker) NewUints(values ...interface{}) (Uints, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Uints), nil
}

// NewBools dynamically creates and asserts the returning function is of type Bools.
// This function is used by the compose library to compile functions together.
func (f *Maker) NewBools(values ...interface{}) (Bools, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Bools), nil
}

// NewStrings dynamically creates and asserts the returning function is of type Strings.
// This function is used by the compose library to compile functions together.
func (f *Maker) NewStrings(values ...interface{}) (Strings, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Strings), nil
}

// NewListOfBytes dynamically creates and asserts the returning function is of type ListOfBytes.
// This function is used by the compose library to compile functions together.
func (f *Maker) NewListOfBytes(values ...interface{}) (ListOfBytes, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(ListOfBytes), nil
}
